"""
Задание 1.

Приведен код, который позволяет сохранить в
массиве индексы четных элементов другого массива

Сделайте замеры времени выполнения кода с помощью модуля timeit

Оптимизируйте, чтобы снизить время выполнения
Проведите повторные замеры

Добавьте аналитику: что вы сделали и почему!!!
Без аналитики задание считается не принятым
"""

import timeit
nums = [10, 12, 1, 9, 4, 5, 8]

def func_1(nums):
    new_arr = []
    for i in range(len(nums)):
        if nums[i] % 2 == 0:
            new_arr.append(i)
    return new_arr
print('№1- ', timeit.timeit('func_1(nums)', 'from __main__ import func_1, nums', number=1000))

def func_2(nums):
    for i in range(0, len(nums), 2):
        True
print('№2- ', timeit.timeit('func_2(nums)', 'from __main__ import func_2, nums', number=1000))

def func_3(nums):
    res = [i for j, i in enumerate(nums) if not j % 2]
print('№3- ', timeit.timeit('func_3(nums)', 'from __main__ import func_3, nums', number=1000))

# Оба варианта (№2,№3) быстрее исходного, так как в №1 варианте идет с начала перебор элементов в массиве и
# только потом проврека на остаток от деления. В №2 тоже есть перебор элементов в массиве, но там перебор проходит через один элемент,
# что позволяет сократить перебор элементов в 2 раза. В №3 варианте идет перебор элементов и проверка на четность индексов,
# но enumerate за нас уже перебирает индексы, что позволяет также сократить время.
# №1-  0.0006064999999999994
# №2-  0.00025450000000000125
# №3-  0.000530199999999998